@page "/newDashboard/{mode}"
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@using Quantaflare.Data
@inject Services.MyChartService myChartService
@inject ISnackbar Snackbar
@inject HttpClient Http
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime


<PageTitle>New Unit Dashboard</PageTitle>

<MudContainer MaxWidth="MaxWidth.False">
    <MudGrid>
        <MudItem md="12" sm="12" xs="12">
            <MudPaper Class="d-flex flex-column justify-space-between pa-4 mt-5 mb-5

" Elevation="2">
                <MudGrid>
                     <MudItem xs="12" sm="12" md="12">
                            <MudStack Row = "false">
                                <MudText Typo="Typo.h5">New Unit Dashboard</MudText>
                            </MudStack>

                    </MudItem>

                    <MudItem xs="12" sm="12" md="12">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                            <MudTextField @bind-Value="TextValue" Label="Name" Variant="Variant.Outlined"></MudTextField>
                            <MudRadioGroup @bind-Value="Dense_Radio">
                                <MudRadio Value="true" Color="Color.Primary" Dense="true">Unit Dashboard</MudRadio>
                                <MudRadio Value="false" Color="Color.Secondary" Dense="false">Cluster Dashboard</MudRadio>
                        </MudRadioGroup>
                        </MudStack>
                    </MudItem>
                </MudGrid>

                <MudGrid>
                    <MudItem xs="6" sm="6" md="6" Class="mt-5 ">
                        <MudText Class="mb-5">Select a Widget to be added to dashboard </MudText>
                        <MudIconButton Target="_blank"
                                       Variant="Variant.Outlined"
                                       Icon="@Icons.Material.Filled.MultilineChart"
                                       Color="Color.Primary" OnClick="LineChartPaper" Class="big-icon-button mr-5" />

                        <MudIconButton Target="_blank"
                                   Variant="Variant.Outlined"
                                   Icon="@Icons.Material.Filled.BarChart"
                                       Color="Color.Primary" OnClick="BarChartPaper" Class="big-icon-button mr-5" />
                            
                        <MudIconButton Target="_blank"
                                       Variant="Variant.Outlined"
                                   Icon="@Icons.Material.Filled.PieChart"
                                       Color="Color.Primary" aria-label="PieChart" Class="big-icon-button mr-5" />
                        <MudIconButton Target="_blank"
                                       Variant="Variant.Outlined"
                                       Icon="@Icons.Material.Filled.TableChart"
                                       Color="Color.Primary" aria-label="TimeSeriesTable" Class="big-icon-button mr-5" />

                    </MudItem>
                    
                </MudGrid>
                <MudGrid>
                    <MudContainer Style="text-align: right;">
                        @* <MudButton Color="Color.Primary" OnClick="Save" Variant="Variant.Outlined">Edit</MudButton> *@
                        <MudButton Color="Color.Primary" OnClick="Save" Variant="Variant.Filled">Save dashboard</MudButton>
                    </MudContainer>
                </MudGrid>
            </MudPaper>
        </MudItem>
       
        @if (showLineChart)
        {
            <MudGrid>
            <MudItem xs="12">
                    <MudGrid Id="sortable-grid">
                    @for (int i=0;i<lineChartList.Count;i++)
                    {
                            int localindex = i;
                            var lineChart = lineChartList[i];
                            <MudItem xs="@breaks[localindex]">
                                <MudPaper>
                                    <MudText Typo="Typo.h6" Style="text-decoration: underline;">@lineChart.chartTitle</MudText>
                                        <MudChart ChartType="ChartType.Line"
                                                  ChartSeries="@lineChart.series"
                                                  @bind-SelectedIndex="Index"
                                                  XAxisLabels="@lineChart.xAxisLabels"
                                                  Width="100%"
                                                  Height="350px"
                                                  ChartOptions="@options" />

                                        <MudGrid>
                                            @*<MudItem xs="6"> // Need to maintain seprate index for each chart, commenting now
                                    <MudText Typo="Typo.body1" Class="py-3">Selected: @(Index < 0 ? "None" : lineChart.series[Index].Name)</MudText>
                                    </MudItem>*@
                                            <MudItem xs="6">
                                                <MudSlider @bind-Value="options.LineStrokeWidth" Min="1" Max="10" Color="Color.Info">Line Width: @options.LineStrokeWidth.ToString()</MudSlider>
                                            </MudItem>
                                        </MudGrid>
                                    <MudGrid>
                                        <MudContainer Style="text-align: right;">
                                            <MudIconButton Icon="@Icons.Material.Filled.ZoomOut" OnClick="(()=>UpdateBreaks(localindex,-1))" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Secondary" />
                                            <MudIconButton Icon="@Icons.Material.Filled.ZoomIn" OnClick="(()=>UpdateBreaks(localindex,1))" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" />
                                        </MudContainer>
                                    </MudGrid>
                            </MudPaper>
                        </MudItem>
                    }
                 </MudGrid>
            </MudItem>
          </MudGrid>
        }
        
    </MudGrid>
</MudContainer>


<style>
    .big-icon-button {
        font-size: 48px; /* Adjust size as needed */
        width: 80px; /* Custom width */
        height: 80px; /* Custom height */
    }
</style>

@code {
    [Parameter]
    public string? clusterid { get; set; } = "0";

    [Parameter]
    public string Mode { get; set; }

    public string TextValue { get; set; } = string.Empty;
    public bool Dense_Radio { get; set; } = true;
    private readonly DialogOptions _maxWidth = new() { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true, BackdropClick = false};

    private bool showLineChart = false;
    private bool showBarChart = false;
    private int Index { get; set; } = -1; // Default selected index
    private string[] xAxisLabels = new string[0];
    private List<MudBlazor.ChartSeries> series = new List<MudBlazor.ChartSeries>();
    private MudBlazor.ChartOptions options = new MudBlazor.ChartOptions();

    private QFChart ReturnedLineChart = new QFChart();
    private Dashboard ds;
    private List<ChartSeriesData> lineChartList = new List<ChartSeriesData>();

    private Dictionary<ChartSeriesData, ChartPosition> chartPositions = new Dictionary<ChartSeriesData, ChartPosition>();
    private bool isDragging = false;
    private int initialX, initialY;
    private double offsetX;
    private double offsetY;
    private ChartSeriesData draggingChart = new ChartSeriesData();

    private double nextX; // X position for the next chart
    private double nextY; // Y position for the next chart
    private const double padding = 20; // Padding between charts
    private double chartWidth;  // Chart width
    private double chartHeight; // Chart height

    private double maxWidth; // Maximum width for a row (container or viewport width)
    private double availableWidth; // Available width to fit the charts in a row

    private WindowSize windowSize=new WindowSize();
    int[] breaks = new int[10] { 3, 4, 2, 3, 3, 2, 4,3,2,4 };
    int _papers = 0;
    int papers { get { return _papers; } set { UpdatePapers(value); } }

    Justify justification = Justify.FlexStart;


    protected async override Task OnInitializedAsync()
    {
        // Get the URI of the current request
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);

        // Parse the query parameters
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        clusterid = query["clusterid"]; 
        await SetInitialChartPositionAndSize();
        if (Mode == "new")
        {
            //Set Default name to new dashboard
            TextValue = await setDefaultDashboardName(clusterid);
        }
        else if (Mode == "edit")
        {
            var dashboardName = query["dashboardName"];
            ds = await editDashboard(clusterid, dashboardName);
        }

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || lineChartList.Count > 0)
        {
            await JSRuntime.InvokeVoidAsync("initSortable", "sortable-grid", DotNetObjectReference.Create(this));
        }
    }

    [JSInvokable]
    public void OnUpdateJS(int oldIndex, int newIndex)
    {
        var item = lineChartList[oldIndex];
        lineChartList.RemoveAt(oldIndex);
        lineChartList.Insert(newIndex, item);
        StateHasChanged();
    }

    private async Task SetInitialChartPositionAndSize()
    {
        // Get container size or viewport size using JSInterop
        windowSize = await GetWindowSize();

        // Set maximum width for charts based on the available width (e.g., 80% of the container width)
        availableWidth = windowSize.Width * 0.8;

        // Dynamically calculate initial positions based on container size
        nextX = windowSize.Width * 0.1; // Set 9% of window width as initial X position
        nextY = windowSize.Height * 0.24; // Set 10% of window height as initial Y position

        // Dynamically calculate chart size based on available space
        chartWidth = availableWidth / 4;  // Set chart width to fit 3 charts per row
        chartHeight = windowSize.Height * 0.3; // Set chart height as 30% of window height

        // Set the max width for the row to fit the available space
        maxWidth = availableWidth;
    }

    private async Task<WindowSize> GetWindowSize()
    {
        // Get window size via JSInterop
        return await JSRuntime.InvokeAsync<WindowSize>("getWindowSize");
    }

    private ChartPosition CalculateNextPosition()
    {

        // Create the position for the next chart based on the current X, Y
        var position = new ChartPosition
            {
                X = nextX,
                Y = nextY,
                Width = chartWidth,
                Height = chartHeight
            };

        // Update next position for the next chart
        nextX += chartWidth + padding; // Move next chart to the right

        // If nextX exceeds the available width, move to the next row
        if (nextX  > maxWidth) // Dynamically check if we exceed the max width
        {
            nextX = windowSize.Width * 0.1; // Reset X to the starting point (5% of the container width)
            nextY += chartHeight + padding; // Move down to the next row (add padding for spacing)
        }

        return position;
    }


    void UpdatePapers(int value)
    {

        int[] newbreaks = Enumerable.Repeat(3, value).ToArray();

        for (int i = 0; i < newbreaks.Length; i++)
        {
            if (i < breaks.Length)
            {
                newbreaks[i] = breaks[i];
            }
        }

        breaks = newbreaks;

        _papers = value;

        StateHasChanged();
    }

    void UpdateBreaks(int index,int changeamount)
    {
        List<int> newbreaks = breaks.ToList();
        if (newbreaks[index] + changeamount > 12 || newbreaks[index] + changeamount < 1) return; //don't go above 12 or below 1
        newbreaks[index] += changeamount;

        breaks = newbreaks.ToArray();

        StateHasChanged();
    }


    private async Task<Dashboard> CreateNewDashboard()
    {

        var newDash = new Dashboard();
        newDash.clusterId = int.Parse(clusterid);
        newDash.createdOn = DateTime.Now;
        newDash.dashName = TextValue;
        newDash.dashType = Dense_Radio ? "Unit Dashboard" : "Cluster Dashboard";
        var response = await Http.PostAsJsonAsync("api/Dashboard/PostDashboard", newDash);
        if (response.IsSuccessStatusCode)
        {
            newDash.dashid = await response.Content.ReadFromJsonAsync<int>();
        }
        else
        {
            Console.WriteLine("Failed in creating new Dashboard.");
        }
        return newDash;
    }

    private async Task<Dashboard> CreateNewDashboard(Dictionary<int, ChartPosition> chartDetail)
    {

        var newDash = new Dashboard();
        newDash.clusterId = int.Parse(clusterid);
        newDash.createdOn = DateTime.Now;
        newDash.dashName = TextValue;
        newDash.dashType = Dense_Radio ? "Unit Dashboard" : "Cluster Dashboard";
        newDash.QFChartList.Add(chartDetail);
        var response = await Http.PostAsJsonAsync("api/Dashboard/PostDashboard", newDash);
        if (response.IsSuccessStatusCode)
        {
            newDash.dashid = await response.Content.ReadFromJsonAsync<int>();
        }
        else
        {
            Console.WriteLine("Failed in creating new Dashboard.");
        }
        return newDash;
    }

    private async Task<Dashboard> editDashboard(string clusterid, string dashboardName)
    {
        Dashboard oldDash = new Dashboard();
        if (dashboardName != null)
        {
            TextValue = dashboardName;
        }
        var url_dashname = $"api/Dashboard/GetDashboardDetails?clusterid={clusterid}&&dashname={dashboardName}";
        oldDash = await Http.GetFromJsonAsync<Dashboard>(url_dashname);
        if (oldDash != null)
        {
            Dense_Radio = (oldDash.dashType == "Unit Dashboard") ? true : false;
            if (oldDash.QFChartList != null)
            {
                List<int> chartIdList = new List<int>();
                foreach (var chart in oldDash.QFChartList)
                {
                    foreach (var kvp in chart)
                    {
                        chartIdList.Add(kvp.Key);
                        ChartPosition position = kvp.Value;
                    }
                }
                var url_QFChart = $"api/Stream/GetQFChart?chartId={string.Join(",", chartIdList)}";
                try
                {
                    var dashboard_qfChartList = await Http.GetFromJsonAsync<QFChart[]>(url_QFChart);
                    if (dashboard_qfChartList != null)
                    {
                        foreach (var dashboard_chart in dashboard_qfChartList)
                        {
                            if (dashboard_chart.chartType == MudBlazor.ChartType.Line)
                            {
                                showLineChart = true;
                                var lineSeriesData = await myChartService.GetChartInfo(dashboard_chart.chartDataStreamList.Cast<LineChartData>().ToList());
                                lineSeriesData.chartTitle = dashboard_chart.chartTitle;
                                var chartPosition = oldDash.QFChartList.SelectMany(chartDict => chartDict)
                                                             .FirstOrDefault(kvp => kvp.Key == dashboard_chart.chartID).Value;
                                lineChartList.Add(lineSeriesData);
                                if (chartPosition != null)
                                {
                                    chartPositions[lineSeriesData] = chartPosition;
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    ShowAlert("No Data to display check other Dashboard !!", Defaults.Classes.Position.BottomRight, Severity.Error);
                }
            }
        }
        return oldDash;
    }

    private async Task<string> setDefaultDashboardName(string clusterid)
    {
        string newDashName ="New Dashboard";
        //Get Dashboard name for by default New Dashboard
        var url_dashname = $"api/Dashboard/GetDashboardName?clusterid={clusterid}";
        var response = await Http.GetAsync(url_dashname);
        if (response.IsSuccessStatusCode)
        {
            var responseName = await response.Content.ReadAsStringAsync();
            if (responseName.StartsWith("New Dashboard"))
            {
                var numberPart = responseName.Substring(newDashName.Length).Trim();

                // If the number part is empty, start from 1
                if (string.IsNullOrWhiteSpace(numberPart))
                {
                    // Start from "New Dashboard 1"
                    newDashName = "New Dashboard 1";
                }
                else if (int.TryParse(numberPart, out int dashboardNumber))
                {
                    // If there is a number, increment it
                    dashboardNumber++;

                    // Create the new dashboard name with the incremented number
                    newDashName = $"New Dashboard {dashboardNumber}";
                }
                else
                {
                    // If the number part isn't valid, handle it (optional)
                    Console.WriteLine("The current dashboard name does not have a valid number.");
                }
            }
        }

        return newDashName;
    }

    private async Task LineChartPaper()
    {

        var parameters = new DialogParameters()
        {
            { "Title", "Add Line Chart" },
            {"ClusterId", clusterid}
        };
        var dialog=DialogService.Show<Components.LineChartComponent>("Custom Options Dialog", parameters, _maxWidth);

        var result = await dialog.Result;

        if (result.Data != null && !result.Canceled)
        {

            ReturnedLineChart = (QFChart) result.Data;
            var lineSeriesData = await myChartService.GetChartInfo(ReturnedLineChart.chartDataStreamList.Cast<LineChartData>().ToList());
            lineSeriesData.chartTitle = ReturnedLineChart.chartTitle;
            var newChartPos = CalculateNextPosition(); //new ChartPosition { X = 350, Y = 350 };
            chartPositions[lineSeriesData] = newChartPos;
            lineChartList.Add(lineSeriesData);
            StateHasChanged();
            _papers = lineChartList.Count;
            showLineChart = true;
            var chartDetail = new Dictionary<int, ChartPosition>{
                                 { ReturnedLineChart.chartID, newChartPos }
                                };
            if (chartDetail != null)
            {

                if (ds == null)
                {
                    ds = await CreateNewDashboard(chartDetail);

                }
                else
                {
                    ds.QFChartList.Add(chartDetail);
                    var response = await Http.PostAsJsonAsync("api/Dashboard/UpdateDashboard", ds);
                    if (response.IsSuccessStatusCode)
                    {
                        var rowsAffected = await response.Content.ReadFromJsonAsync<int>();
                        Console.WriteLine($"Received Cluster ID: {rowsAffected}");
                    }
                }
            }
        }
    }

    private Task BarChartPaper()
    {
        var parameters = new DialogParameters()
        {
            { "Title", "Add Bar Chart" },
            {"ClusterId", clusterid}
        };

        return DialogService.ShowAsync<Components.BarChartComponent>("Custom Options Dialog", parameters, _maxWidth);

    }

    private async Task Save()
    {
        if (string.IsNullOrEmpty(TextValue))
        {
            ShowAlert("Please Enter Dashboard name before saving !!", Defaults.Classes.Position.BottomRight,Severity.Error);
        }
        else
        {
            if (ds == null)
            {
                ds = await CreateNewDashboard();
                if(ds == null)
                {
                    ShowAlert("Failed in New Dashboard Creation !!", Defaults.Classes.Position.BottomRight, Severity.Error);
                }
            }
            else
            {
                if (TextValue != ds.dashName || Dense_Radio != ((ds.dashType == "Unit Dashboard")? true:false))
                {
                    var dataToUpdate = new
                    {
                        clusterid = ds.clusterId,
                        dashid = ds.dashid,
                        dashname = ds.dashName,
                        TextValue = TextValue,
                        dashType = Dense_Radio ? "Unit Dashboard" : "Cluster Dashboard"
                    };

                    var response = await Http.PostAsJsonAsync("api/Dashboard/UpdateDashboardName", dataToUpdate);
                    if (response.IsSuccessStatusCode)
                    {
                        var rowsAffected = await response.Content.ReadFromJsonAsync<int>();
                        Console.WriteLine($"Received Cluster ID: {rowsAffected}");
                    }
                }
            }
            Navigation.NavigateTo("/managedash");
        }
    }

    private void Edit()
    {
        if (string.IsNullOrEmpty(TextValue))
        {
            ShowAlert("Please Enter Dashboard name before saving !!", Defaults.Classes.Position.BottomRight,Severity.Error);
        }
        else
        {
            ShowAlert("Dashboard saved !!", Defaults.Classes.Position.BottomRight, Severity.Success);
        }
    }

    private void OnMouseDown(MouseEventArgs e, ChartSeriesData chart)
    {
        isDragging = true;
        initialX = (int)e.ClientX;
        initialY = (int)e.ClientY;
    }

    private void OnMouseUp()
    {
        isDragging = false;
        draggingChart = null; // Clear the dragging chart
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (isDragging && draggingChart != null)
        {
            /*var position = chartPositions[draggingChart];
            position.X = e.ClientX - offsetX;
            position.Y = e.ClientY - offsetY;*/
            offsetX = (int)e.ClientX - initialX;
            offsetY = (int)e.ClientY - initialY;
            StateHasChanged(); // Refresh the UI
        }
    }


    void ShowAlert(string message, string position,Severity sev)
    {
        Snackbar.Clear();
        Snackbar.Configuration.PositionClass = position;
        Snackbar.Add(message, sev, c => c.SnackbarVariant = Variant.Outlined);
    }
    
    public class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}
